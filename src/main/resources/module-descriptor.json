{"name":"module-kafka","displayName":"Kafka Module","version":"1.0.4-SNAPSHOT","components":[{"hidden":false,"displayName":"Kafka Consumer","description":"Consumes messages from Kafka broker whenever an event is published on one of the given topics. A list of topics this consumer should listen to is mandatory for this component. The key deserializer and value deserializer must be consisten with the data this consumer will be listening to.","fullyQualifiedName":"com.reedelk.kafka.component.KafkaConsumer","type":"INBOUND","output":{"description":"A map object containing a \u0027key\u0027 property and a \u0027value\u0027 property defining the received Kafka record.","dynamicPropertyName":"","payload":["com.reedelk.kafka.internal.type.KafkaRecord"],"attributes":["com.reedelk.kafka.internal.attribute.KafkaConsumerAttributes"]},"properties":[{"mandatory":false,"name":"configuration","initValue":"###USE_DEFAULT_VALUE###","displayName":"Configuration","type":{"classname":"com.reedelk.module.descriptor.model.property.ObjectDescriptor","instance":{"shared":"YES","dialogTitle":"Kafka Consumer Configuration","collapsible":"NO","typeFullyQualifiedName":"com.reedelk.kafka.component.KafkaConsumerConfiguration","objectProperties":[{"mandatory":false,"name":"bootstrapServers","example":"localhost:9092","initValue":"localhost:9092","hintValue":"localhost:9092,localhost:9096","description":"A list of host/port pairs to use for establishing the initial connection to the Kafka cluster. The client will make use of all servers irrespective of which servers are specified here for bootstrapping\u0026mdash;this list only impacts the initial hosts used to discover the full set of servers. This list should be in the form \u003ccode\u003ehost1:port1,host2:port2,...\u003c/code\u003e. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).","displayName":"Bootstrap Servers","defaultValue":"localhost:9092","type":{"classname":"com.reedelk.module.descriptor.model.property.PrimitiveDescriptor","instance":{"type":"java.lang.String"}},"whens":[]},{"mandatory":false,"name":"groupId","example":"test","initValue":"###USE_DEFAULT_VALUE###","hintValue":"test","description":"A unique string that identifies the consumer group this consumer belongs to. This property is required if the consumer uses either the group management functionality by using \u003ccode\u003esubscribe(topic)\u003c/code\u003e or the Kafka-based offset management strategy.","displayName":"Group ID","defaultValue":"test","type":{"classname":"com.reedelk.module.descriptor.model.property.PrimitiveDescriptor","instance":{"type":"java.lang.String"}},"whens":[]},{"mandatory":false,"name":"keyDeserializer","initValue":"STRING","description":"The deserializer type to be used for the Kafka record key","displayName":"Key Deserializer","defaultValue":"STRING","type":{"classname":"com.reedelk.module.descriptor.model.property.EnumDescriptor","instance":{"nameAndDisplayNameMap":{"FLOAT":"Float","BYTE_ARRAY":"Byte Array","STRING":"String","DOUBLE":"Double","UUID":"UUID","VOID":"Void","INTEGER":"Integer","LONG":"Long","SHORT":"Short"},"type":"java.lang.Enum"}},"whens":[]},{"mandatory":false,"name":"valueDeserializer","initValue":"STRING","description":"The deserializer type to be used for the Kafka record value","displayName":"Value Deserializer","defaultValue":"STRING","type":{"classname":"com.reedelk.module.descriptor.model.property.EnumDescriptor","instance":{"nameAndDisplayNameMap":{"FLOAT":"Float","BYTE_ARRAY":"Byte Array","STRING":"String","DOUBLE":"Double","UUID":"UUID","VOID":"Void","INTEGER":"Integer","LONG":"Long","SHORT":"Short"},"type":"java.lang.Enum"}},"whens":[]},{"mandatory":false,"name":"enableAutoCommit","example":"false","initValue":"true","description":"If true the consumer\u0027s offset will be periodically committed in the background.","displayName":"Enable Auto Commit","defaultValue":"false","type":{"classname":"com.reedelk.module.descriptor.model.property.PrimitiveDescriptor","instance":{"type":"java.lang.Boolean"}},"whens":[]},{"mandatory":false,"name":"autoCommitInterval","example":"1500","initValue":"1000","hintValue":"1000","description":"The frequency in milliseconds that the consumer offsets are auto-committed to Kafka if \u003ccode\u003eenable.auto.commit\u003c/code\u003e is set to \u003ccode\u003etrue\u003c/code\u003e.","displayName":"Auto Commit Interval (ms)","defaultValue":"1000","type":{"classname":"com.reedelk.module.descriptor.model.property.PrimitiveDescriptor","instance":{"type":"java.lang.Integer"}},"whens":[]}],"type":"com.reedelk.module.descriptor.model.property.ObjectDescriptor$TypeObject"}},"whens":[]},{"mandatory":false,"name":"topics","initValue":"###USE_DEFAULT_VALUE###","description":"List of topics the consumer will be subscribed to.","displayName":"Subscription Topics","type":{"classname":"com.reedelk.module.descriptor.model.property.ListDescriptor","instance":{"valueType":{"classname":"com.reedelk.module.descriptor.model.property.PrimitiveDescriptor","instance":{"type":"java.lang.String"}},"tabGroup":"Topics","type":"java.util.List"}},"whens":[]},{"mandatory":false,"name":"pollTimeout","group":"Advanced","example":"500","initValue":"###USE_DEFAULT_VALUE###","hintValue":"100","description":"The maximum time to block before the next poll in milliseconds.","displayName":"Poll timeout (ms)","defaultValue":"100","type":{"classname":"com.reedelk.module.descriptor.model.property.PrimitiveDescriptor","instance":{"type":"java.lang.Integer"}},"whens":[]}]},{"hidden":false,"displayName":"Kafka Producer","description":"Sends a single record or multiple records to a Kafka topic. If the component input is a map, then it \u003cb\u003emust\u003c/b\u003e contain a \u0027key\u0027 property and a \u0027value\u0027 property defining the kafka record to be sent. If the map does not contain a key and a value property an exception will be thrown. The type of the key and of the value must be consistent with the key and value serializers chosen in the Producer Configuration. If the component input is a list, the list must contain map objects. The map objects in the list \u003cb\u003emust\u003c/b\u003e contain a \u0027key\u0027 property and a \u0027value\u0027 property defining the kafka record to be sent. If the map does not contain a key and a value property an exception will be thrown. The topic and producer configuration properties are mandatory in order to use the Kafka Producer component.","fullyQualifiedName":"com.reedelk.kafka.component.KafkaProducer","type":"PROCESSOR","input":{"description":"If the component input is a map, then it must contain a \u0027key\u0027 property and a \u0027value\u0027 property defining the kafka record to be sent. If the component input is a list, the list must contain map objects. The map objects in the list must contain a \u0027key\u0027 property and a \u0027value\u0027 property defining the kafka record to be sent.","payload":["com.reedelk.kafka.internal.type.KafkaRecord","com.reedelk.kafka.internal.type.ListOfKafkaRecord"]},"output":{"description":"The Kafka Producer component output is the original input message. The payload is not changed by this component.","dynamicPropertyName":"","payload":["com.reedelk.runtime.api.annotation.ComponentOutput$PreviousComponent"],"attributes":["com.reedelk.kafka.internal.attribute.KafkaProducerAttributes","com.reedelk.kafka.internal.attribute.KafkaProducerAttributesList"]},"properties":[{"mandatory":false,"name":"configuration","initValue":"###USE_DEFAULT_VALUE###","displayName":"Configuration","type":{"classname":"com.reedelk.module.descriptor.model.property.ObjectDescriptor","instance":{"shared":"YES","dialogTitle":"Kafka Producer Configuration","collapsible":"NO","typeFullyQualifiedName":"com.reedelk.kafka.component.KafkaProducerConfiguration","objectProperties":[{"mandatory":false,"name":"bootstrapServers","example":"localhost:9092","initValue":"localhost:9092","hintValue":"localhost:9092,localhost:9096","description":"A list of host/port pairs to use for establishing the initial connection to the Kafka cluster. The client will make use of all servers irrespective of which servers are specified here for bootstrapping\u0026mdash;this list only impacts the initial hosts used to discover the full set of servers. This list should be in the form \u003ccode\u003ehost1:port1,host2:port2,...\u003c/code\u003e. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).","displayName":"Bootstrap Servers","defaultValue":"localhost:9092","type":{"classname":"com.reedelk.module.descriptor.model.property.PrimitiveDescriptor","instance":{"type":"java.lang.String"}},"whens":[]},{"mandatory":false,"name":"clientId","example":"client01","initValue":"###USE_DEFAULT_VALUE###","hintValue":"client01","description":"An id string to pass to the server when making requests. The purpose of this is to be able to track the source of requests beyond just ip/port by allowing a logical application name to be included in server-side request logging.","displayName":"Client Id","defaultValue":"client01","type":{"classname":"com.reedelk.module.descriptor.model.property.PrimitiveDescriptor","instance":{"type":"java.lang.String"}},"whens":[]},{"mandatory":false,"name":"keySerializer","example":"FLOAT","initValue":"STRING","description":"The serializer type to be used for the Kafka record key.","displayName":"Key Serializer","defaultValue":"STRING","type":{"classname":"com.reedelk.module.descriptor.model.property.EnumDescriptor","instance":{"nameAndDisplayNameMap":{"FLOAT":"Float","BYTE_ARRAY":"Byte Array","STRING":"String","DOUBLE":"Double","UUID":"UUID","VOID":"Void","INTEGER":"Integer","LONG":"Long","SHORT":"Short"},"type":"java.lang.Enum"}},"whens":[]},{"mandatory":false,"name":"valueSerializer","example":"FLOAT","initValue":"STRING","description":"The serializer type to be used for the Kafka record value.","displayName":"Value Serializer","defaultValue":"STRING","type":{"classname":"com.reedelk.module.descriptor.model.property.EnumDescriptor","instance":{"nameAndDisplayNameMap":{"FLOAT":"Float","BYTE_ARRAY":"Byte Array","STRING":"String","DOUBLE":"Double","UUID":"UUID","VOID":"Void","INTEGER":"Integer","LONG":"Long","SHORT":"Short"},"type":"java.lang.Enum"}},"whens":[]}],"type":"com.reedelk.module.descriptor.model.property.ObjectDescriptor$TypeObject"}},"whens":[]},{"mandatory":false,"name":"topic","example":"payments","initValue":"###USE_DEFAULT_VALUE###","hintValue":"payments","description":"The topic the records sent by this producer will be appended to.","displayName":"Topic","type":{"classname":"com.reedelk.module.descriptor.model.property.PrimitiveDescriptor","instance":{"type":"java.lang.String"}},"whens":[]}]}],"types":[{"global":false,"type":"com.reedelk.kafka.internal.attribute.KafkaConsumerAttributes","extendsType":"com.reedelk.runtime.api.message.MessageAttributes","description":"","mapKeyType":"java.lang.Object","mapValueType":"java.lang.Object","functions":[],"properties":[{"name":"key","type":"java.lang.String","example":"","description":""},{"name":"topic","type":"java.lang.String","example":"","description":""},{"name":"offset","type":"long","example":"","description":""},{"name":"timestamp","type":"long","example":"","description":""},{"name":"envelope","type":"int","example":"","description":""}]},{"global":false,"type":"com.reedelk.kafka.internal.attribute.KafkaProducerAttributes","extendsType":"com.reedelk.runtime.api.message.MessageAttributes","description":"","mapKeyType":"java.lang.Object","mapValueType":"java.lang.Object","functions":[],"properties":[{"name":"timestamp","type":"long","example":"","description":""},{"name":"partition","type":"int","example":"","description":""},{"name":"topic","type":"java.lang.String","example":"","description":""},{"name":"success","type":"boolean","example":"","description":""},{"name":"record","type":"java.util.Map","example":"","description":""}]},{"global":false,"type":"com.reedelk.kafka.internal.attribute.KafkaProducerAttributesList","extendsType":"com.reedelk.runtime.api.message.MessageAttributes","description":"","mapKeyType":"java.lang.Object","mapValueType":"java.lang.Object","functions":[],"properties":[{"name":"metadata","type":"java.util.List","example":"","description":""},{"name":"metadata","type":"boolean","example":"","description":""}]},{"global":false,"type":"com.reedelk.kafka.internal.type.KafkaRecord","extendsType":"java.util.HashMap","description":"","mapKeyType":"java.lang.Object","mapValueType":"java.lang.Object","functions":[],"properties":[{"name":"key","type":"java.lang.Object","example":"","description":""},{"name":"value","type":"java.lang.Object","example":"","description":""}]},{"global":false,"type":"com.reedelk.kafka.internal.type.ListOfKafkaRecord","extendsType":"java.util.ArrayList","description":"","listItemType":"com.reedelk.kafka.internal.type.KafkaRecord","functions":[],"properties":[]}]}